---
title: "My Data-fetching Preference in Next.js"
publishedAt: "2021-07"
image: "/images/blog/server-client-communication-banner.jpeg"
readingTime: "20"
category: "next"
summary: "I want to describe the way I like to implement server client communication in my next.js apps."
---

Front-end programming is getting more advanced every day, new solutions have entered the scene based on recent needs, and we have to adapt our apps with performant solutions.

When it comes to data fetching and server state management, there are so many different approaches to choose from. some of those are better than the others but in some cases, you will just end up picking the one that its developer experience suits you better. TBH most of the time you have to adapt yourself and your approaches to business requirements but there will be always some right ways to choose.
Here I want to show you the way I personally like to implement my projects data-fetching and server state management.

But first, let's have a quick overview of different options of data fetching strategies in next.js apps. You can read more about those concepts [here](https://www.youtube.com/watch?v=eMwTEo6AjDc). you will need some basic react and next.js understanding to understand these concepts

## Data Fetching Strategies in Next.js Apps

### 1. Server Side Rendering ( SSR )

With SSR you can generate an entire page on demand for every user specifically and show a completely rendered page on the first load, pretty convenient huh? not at all.
An important point here is that you are no longer limited to client-side coding anymore as you were in react development. The decisions you make will directly affect your server performance.
You can use the SSR approach however you should strongly avoid using it until you have to do so( probably never ).

- **_Benefits:_**
  - A server-side rendered application enables pages to load faster, improving the user experience.
  - Rendered content at first ready for search engines crawler robots which is ideal for SEO.

<br />

- **_Downsides:_**
  - Slower <abbr title="time to first byte">TTFB</abbr>
  - The webpage interactions are fewer.
  - Slow page rendering.
  - Full UI reloads.
  - Frequent server requests.
  - A heavy load for server on more requests

### 2. Client side rendering

Client-side rendering is the way we coded in react projects. In this method, we fetch page needed data on the client side and the rendering process will take place in the client's machine.

- **_Benefits:_**
  - Faster <abbr title="time to first byte">TTFB</abbr>
  - Reducing the load from the server and transferring it to the client machine.

<br />

- **_Downsides:_**
  - Slower <abbr title="first contentful paint">FCP</abbr>
  - Heavier initial page load(loading framework)
  - Empty content for search engines crawler robots ( almost no SEO )

### 3. Static Site Generation ( SSG )

We already know about statically generated websites. It's not a new concept, we were using it since the beginning.
This method lets you build your pages at build time instead of doing it on demand for every single request. But building rich web experiences wasn't something we could do easily before, tools like [Next.js](https://nextjs.org/), [gatsby](https://www.gatsbyjs.com/), [nuxt](https://nuxtjs.org/), [jekyll](https://jekyllrb.com/) and ... introduced us better ways of building static-generated websites with more dynamic performance.

- **_Benefits:_**
  - Faster load times
  - Rendered content at first, ready for search engines crawler robots to index which is ideal for SEO.

<br />

- **_Downsides:_**
  - Builds will take longer to complete
  - No user-specific content
  - Once you build a page, there is no way to revalidate its data

### 4. Incremental Static Regeneration ( ISR )

ISR is a new paradigm introduced by [Next.js](https://nextjs.org/). It combines the advantages of SSG and SSR to build websites.

- **_Benefits:_**
  - All of SSG benefits
  - Fast <abbr title="time to first byte">TTFB</abbr> ( as most of the times we serve statically generated page )
  - Fresh content, as you can set the max stale time

<br />

- **_Downsides:_**
  - Builds will take longer to complete
  - No user specific content
  - Slow <abbr title="time to first byte">TTFB</abbr> for pages that wasn't statically cached before.

### 5. SSG/ISR + CSR

This is my favorite, you can use ISR or SSG for building most of the important parts of a page at build time while you can get more fresh and user-specific data on the client side.
For this approach, we need to separate our data into two different parts: shared between request and specific for every request. for example, below you can see a payload of data for a product page of an e-commerce website.

```js
product: {
  id, name, description, isLiked, similars;
}
```

`id` is something that will not change, name and description may get change sometimes, isLiked and similars are some parts of this response that will be different based on request.

The best way to implement this page is to first get data at build time with help of ISR, removing its dynamic parts( isLiked, similars ), and passing remains to the page as props.

```javascript
export const getStaticProps = async ({ params }) => {
    const result = await ProductServices.getDetail(params.slug);
    return {
      props: { product: result.product },
    };
  };
}
export const getStaticPaths = async ({ locales }) => {
  const priorProducts = await ProductServices.getPriors(1000);
  const paths = priorProducts.reduce((acc, { slug }) => {
    locales.forEach((locale) => {
      	acc.push({ params: { slug }, locale });
    });
    return acc;
  }, []);
  return {
    paths,
    fallback: false, *
  };
}
```

\* You can do some interesting stuff with fallback key, you can read more about it [here](https://nextjs.org/docs/api-reference/data-fetching/get-static-paths#fallback-false).

On the client side, I use <abbr title="Stale While Revalidate">[SWR](https://swr.vercel.app)</abbr> as a server state management tool, you can use [react-query](https://react-query.tanstack.com/installation) or any other tool that u like.

```js
// hooks/useProduct.js
import useSWRImmutable from "swr/immutable";
import { useDebugValue } from "react";
import endpoints from "@constants/endpoints";
import Http from "@utils/Http";
export default function useProduct(slug) {
  const key = endpoints.product + "?slug=" + slug;
  const swr = useSWRImmutable(key, async (url) => {
    try {
      const response = await Http.request({ url });
      return response;
    } catch (err) {
      return err;
    }
  });
  useDebugValue(swr.data);
  return swr;
}
```

```js
// pages/product/[slug].js
const router = useRouter();
const product = useProduct(router.query.slug, { initialData: props.product });
```

With this we can use `product.data` everywhere we want. since we filled it at first render, some parts of the product state aren't completed yet( dynamic parts ), but after all the things we did with ISR/SSG, now we have most of our data so we can statically generate parts that are needed for crawler robots to index our page and for end-users to interact with it.
To complete our amazing user experience, for other parts of our page we can use skeleton loading like this:

```jsx
return (
  <>
    <Head title={product.name} description={product.description} />
    <ProductData {...product.data} />
    <SimilarProducts loading={!product.data?.similars} list={product.data?.similars} />
  <>
)
```

Inside `SimilarProducts` component, we show a skeleton loading representing future UI until the loading prop is true.

In this method, we have all the benefits of ISR and SSG without making the user wait for data that has no use for us on the first render.
To prevent a bugging flash on screen after loading data and also to make a better user experience we use skeleton loading, you can paint your own loading with SVG or you can use third-party packages like [react-content-loader](https://skeletonreact.com/).

#### Important note

Since on the client-side, we are calling the same API we called at build time, we can lighten API response by using [GraphQL](https://graphql.org/) to just fetch parts of data that we want.

## Conclusion

As we discussed, choosing SSR blindly is no longer an option for web applications and alternative strategies with fixing issues and expanding the limitations, has become more optimal ways for implementing web applications
All the things said, now you can choose a better way to implement your pages based on your need.

For pages that SEO does not matters for them, like a user profile page, you need to use client-side rendering( first strategy ) without hesitation, and since you are not using any SSR data fetching method here, next.js will statically generate some parts of this page like Layout, Head and ... for you
If you have a shared API for all your pages e.g. list of all countries that you need everywhere in your app, you can mix it with the 5th strategy and fetch it at build time.

In cases that SEO does matters for your page, you need to first distinguish different parts of your data.
If needed data to render your page, is completely shared between different clients, you can choose between 3rd or 4th strategies based on the required time for revalidation of your data.
But if your data has dynamic parts that have different values for different users ( like isLiked and similar property in our example ), you should choose the 5th strategy for your page.

```

```
